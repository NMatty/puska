<!DOCTYPE html>
<html lang="HU">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>C#</title>
        <!--Bootstrap-->
        <link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css" />
        <link rel="stylesheet" href="../css/all.css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" rel="stylesheet" />
        <script src="../bootstrap/js/bootstrap.bundle.min.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-expand-sm bg-dark navbar-dark fixed-top">
            <div class="container-fluid">
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#collapsibleNavbar">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="collapsibleNavbar">
                    <ul class="navbar-nav">
                        <li class="nav-item">
                            <a class="nav-link" href="../html/bootstrap.html">Bootstrap</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../html/javascript.html">Javascript</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link active" href="../html/csharp.html">C#</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../html/sql-seged.html">SQL</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="../html/boot-seged.html">Segéd oldal 2</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
        <div id="main">
            <div class="col-4">
                <div class="vertical-scroll-nav mx-auto">
                    <a href="#toFileBeir">File-ba írás</a>
                    <a href="#toFileBeolvas">File beolvasás</a>
                    <a href="#toFileBeolvas2">File beolvasás részekre bontva (opcionális)</a>
                    <a href="#toDictionary">Szótár (Dictionary) használata</a>
                    <a href="#toMySqlCon">MySqlConnection létrehozása</a>
                    <a href="#toMySqlKapcs">MySql kapcsolat létrehozása</a>
                    <a href="#toMySqlNores">MySql parancs futtatása ; nem várunk vissza eredményt</a>
                    <a href="#toMySqlMoreres">MySql parancs futtatása ; több eredményt várunk vissza</a>
                    <a href="#toMySqlOneres">MySql parancs futtatása ; egy eredményt várunk vissza</a>
                    <a href="#toMySqlUse">MySql => megírt függvények elérése</a>
                    <a href="#toInheritance">Osztály származtatása</a>
                    <a href="#toAbstract">Absztrakt osztály</a>
                    <a href="#toGrid">WPF Grid</a>
                    <a href="#toWpfList">WPF listaBox vagy Táblázat feltöltése az osztály elemeivel</a>
                    <a href="#toCbox">CheckBox és RadioButton használata</a>
                </div>
            </div>

            <div class="col-8 content">
                <button data-bs-toggle="collapse" data-bs-target="#filebair" class="collapseBtn" id="toFileBeir">
                    File-ba írás
                </button>

                <div class="collapse mt-2 mb-5 pe-5" id="filebair">
                        <pre class="szovegek">
Lépések:

Fájl létrehozásához:
    1. FileStream fs = new FileStream("filenev.txt", FileMode.Create);
(vagy)
Fájl hozzáíráshoz:
    1. FileStream fs = new FileStream("filenev.txt", FileMode.Append);
(Ha a feladat más fájlformátumot kér, akkor ne txt-be ments!)

Fájl kezelés értelmezése:
    2. StreamWriter sw = new StreamWriter(fs, Encoding.UTF8);

(Innentől az sw-vel kezeljük a file-t: pl.: sw.WriteLine("Sorszöveg"))
(Ez maga a köztes rész, itt kell kezelni mindent ami a file-hoz tartozik)

StreamWriter bezárása:
    3. sw.Close();
FileStream bezárása:
    4. fs.Close();
                        </pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('responsivityContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="responsivityContent"><code class="language-html">FileStream fs = new FileStream("filenev.txt", FileMode.Create);
StreamWriter sw = new StreamWriter(fs, Encoding.UTF8);

sw.WriteLine("nev;osztaly;atlag"); // iskola tanulóinak az átlagának mentése
// ez egy felső címsort (fejlécet) csinál, ami feladattól függ, hogy kéri-e

for (int i = 0; i < tanulok.Count; i++)
{
    sw.WriteLine($"{tanulok[i].Nev};{tanulok[i].Osztaly};{tanulok[i].Atlag}");
    // Egy előre megadott tanulok osztály listával dolgozik, ahol minden tanulot felír a txt fájlba
    // Magyarul megadjuk ; jelek elé és közé a tartalmat, amit ki akarunk íratni
}

sw.Close();
fs.Close();</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#filebeolvas" class="collapseBtn" id="toFileBeolvas">
                    File beolvasás
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="filebeolvas">
                        <pre class="szovegek">
Listába való beolvasás:
Lépések:

Fájl beolvasása:
    1. FileStream fs = new FileStream("filenev.txt", FileMode.Open);
(Ha a feladat más fájlformátumot kér, akkor ne txt-t nyiss meg!)

Fájl kezelés értelmezése:
    2. StreamReader sr = new StreamReader(fs, Encoding.UTF8);

(Innentől az sr-rel kezeljük a file-t: pl.: sr.ReadLine() => egy sor beolvasása a file-ból)
(Ez maga a köztes rész, itt kell kezelni mindent ami a file-hoz tartozik)

StreamReader bezárása:
    3. sr.Close();
FileStream bezárása:
    4. fs.Close();</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('navbarContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="navbarContent"><code class="language-html">List<Tanulo> tanulok = new List<Tanulo>(); // Tanulo osztályú lista létrehozása
// Ez a lista az alábbiakat kéri: név;osztály;átlag

FileStream fs = new FileStream("filenev.txt", FileMode.Open);
StreamReader sr = new StreamReader(fs, Encoding.UTF8);

// Amennyiben van fejléc (első soros címsor) be kell olvasni az első sort
sr.ReadLine();

while (!sr.EndOfStream) // Amíg a txt végére nem ér
{
    string sor = sr.ReadLine();
    tanulok.Add(new Tanulo(
        sor.Split(';')[1],
        Convert.ToInt32(sor.Split(';')[1]),
        Convert.ToInt32(sor.Split(';')[2])
        ));
    // Így a tanulok listához hozzáadunk mindig egy új Tanulo-t, akiknek az elemeit a ; Split-elésével érünk el.
    // Ha mondjuk a txt file-ban mással választja el őket, akkor nyilván ; helyett a megadott karaktert kell megadni.
}

sr.Close();
fs.Close();</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#filebeolvas2" class="collapseBtn" id="toFileBeolvas2">
                    File beolvasás részekre bontva (opcionális)<br>(pl.: dátumok kezelése külön)
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="filebeolvas2">
<pre class="szovegek">
Sor tartalmainak tárolása listában:
    string[] parts = sor.Split(';');

Tartalom különszedése listán belül:
    string[] innerparts = parts[Tartalom_indexe].Split('.');
Így mostmár hozzá tudunk rendelni az adott részhez: pl.: Convert.ToInt32(innerparts[0])
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('filebeolvas2Content')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="filebeolvas2Content"><code class="language-html">List<Tanulo> tanulok = new List<Tanulo>(); // Tanulo osztályú lista létrehozása
// Ez a lista az alábbiakat kéri: név;osztály;átlag;születési_év;születési_hónap;születési_nap
// Viszont a txt mondjuk nem szedi külön az évet, hónapot napot, hanem egyben írja .-tal elválasztva

FileStream fs = new FileStream("filenev.txt", FileMode.Open);
StreamReader sr = new StreamReader(fs, Encoding.UTF8);

// Amennyiben van fejléc (első soros címsor) be kell olvasni az első sort
sr.ReadLine();

while (!sr.EndOfStream) // Amíg a txt végére nem ér
{
    string sor = sr.ReadLine();
    string[] parts = sor.Split(';');
    string[] innerparts = parts[3].Split('.');
    tanulok.Add(new Tanulo
        (parts[0], 
        Convert.ToInt32(parts[1]), 
        Convert.ToInt32(parts[2]), 
        Convert.ToInt32(innerparts[0]),
        Convert.ToInt32(innerparts[1]),
        Convert.ToInt32(innerparts[2])));
}

sr.Close();
fs.Close();</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#dictionary" class="collapseBtn" id="toDictionary">
                    Szótár (Dictionary) használata
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="dictionary">
<pre class="szovegek">
Dictionary felépítése:
    Dictionary&lt;kulcs_típus, érték_típus&gt; dictionary_név = new Dictionary&lt;megadott_kulcs_típus, mmegadott_érték_típus&gt;();
Fentebb egy kulcsból és értékből álló adatszerkezetet hozunk létre => a kulcs és érték típusa a lényeg, amit mi adunk meg, hogy milyen változóként szeretnénk rögzíteni.

Pl: Ha számokhoz szeretnénk szövegeket rendelni, akkor: 
Dictionary&lt;int, string&gt; kulcs_szoveg = new Dictionary&lt;int, string&gt;();

Innentől már tudunk hozzájuk adni értékeket, pl.: kulcs_szoveg.Add(5, "legjobb jegy");

Dictionary végigjárása:
    foreach (var item in kulcs_szoveg)
    {
        Console.WriteLine($"Kulcs: {item.Key}");
        Console.WriteLine($"Érték: {item.Value}");
    }
Fenti példa végigjárja a Dictionary-t és kiíratja mindegyik kulcsát, majd értékét.
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('dictionaryContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="dictionaryContent"><code class="language-html">List<Tanulo> tanulok = new List<Tanulo>();Dictionary<int, string> kodpar = new Dictionary<int, string>();

kodpar.Add(1, "legrosszabb jegy");
kodpar.Add(2, "elégséges");
kodpar.Add(3, "közepes");
kodpar.Add(4, "jó");
kodpar.Add(5, "legjobb jegy");
            

foreach (var item in kodpar)
{
    Console.WriteLine($"Érdemjegy: {item.Key}");
    Console.WriteLine($"Érdemjegy értéke: {item.Value}");
}</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#mysqlcon" class="collapseBtn" id="toMySqlCon">
                    MySqlConnection létrehozása
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="mysqlcon">
<pre class="szovegek">
DLL importálása:

Solution Explorer => References (jobb klikk) => Add References… => mysql.data.dll fájl kiválasztása => Add => A Reference Manager-en belül kipipálni a mysql.data.dll.t => OK
    => Innentől minden .cs file-ban, ahol használjuk a függvényt importálni kell a kód tetejére: 
            using MySql.Data.MySqlClient;

Kapcsolat megvalósítása:

Kapcsolat megvalósítása:
    1. Egy osztály, amely segítségével az sql részt szeretnénk megvalósítani
    2. Deklarálni kell egy MySqlConnection típusú mezőt, amellyel kapcsolatot tudunk megvalósítani
    3. Konstruktor, amely paraméterként a következő adatokat kapja meg:
        a. host = SQL szerver
        b. dbname = annak az adatbázisnak a neve, amelyet majd kezelni szeretnénk
        c. ui = felhasználónév az adatbázishoz
        d. pw = jelszó az adatbázishoz

</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('mysqlconContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="mysqlconContent"><code class="language-html">class DBConnect
{
    private MySqlConnection con;
    public DBConnect (string host, string dbname, string ui, string pw)
    {
    	con = new MySqlConnection($"Database = {dbname}; Data Source = {host}; User Id = {ui}; Password = {pw};");
    }
}</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#mysqlkapcs" class="collapseBtn" id="toMySqlKapcs">
                    MySql kapcsolat létrehozása
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="mysqlkapcs">
<pre class="szovegek">
Ha az osztály példányosítása megtörtént, már rendelkezünk a megfelelő adatokkal a kapcsolatok létrehozásához. 
Ezen adatokkal létrehozhatjuk az adatbázis kapcsolathoz szükséges függvényeket. 

Az egyik függvény a kapcsolat létrehozására hivatott (Connect()), 
míg a másik a megszüntetésére hivatott (ConnectClose()).
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('mysqlkapcsContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="mysqlkapcsContent"><code class="language-html">private bool Connect()
{
 	try{
 		con.Open();
 		return true;
 	} catch (Exception) 
 	{
 		return false;
 	}
}


private bool ConnectClose()
{
 	try{
 		con.Close();
 		return true;
 	} catch (Exception) 
 	{
 		return false;
 	}
}</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#mysqlnores" class="collapseBtn" id="toMySqlNores">
                    MySql parancs futtatása ; nem várunk vissza eredményt (pl.: insert into, update)
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="mysqlnores">
<pre class="szovegek">
Mi az SQL Injection?
A kód injektálás egyik leggyakoribb alkalmazása. Maga a kód injektálás az az eljárás, mikor egy olyam memóriatartományra, amely normal esetben adatot tartalmaz, illetőleg adatbevitel számára van fenntartva, valamely futtató környezet által futtatható ködot helyezünk el. Abban az esetben, ha az alkalmazás (vagy érintett rendszer) nem ellenőrzi az adott tartalmat akár az input idején akár a feldolgozást megelőzően, az adott kód lefut és segítségével hozzáférést szerezhet egy támadó az egyébként normal esetben nem elérhető erőforrásokhoz.

Fontos: minden olyan esetben, amikor olyan adatokkal szeretnénk dolgozni, amelyeket a felhasználó ad meg valamilyen formában, azoknál ezzel a módszerrel használjuk fel az adatokat.

Lenti példa: Bemutatja, hogy a nev és kor oszlopnak, hogyan tudunk saját paramétereket megadva értékeket beszúrni.
                Paraméter megadása: 
                    cmd.Parameters.AddWithValue("@nev", ÁLTALAD MEGADOTT NÉV);
                    cmd.Parameters.AddWithValue("@kor", ÁLTALAD MEGADOTT KOR);
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('mysqlnoresContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="mysqlnoresContent"><code class="language-html">public void InsertData(TesztOsztaly temp)
{
	if(Connect())
	{
		string query = "INSERT INTO teszttabla(nev, kor) VALUES(@nev, @kor);";
 		MySqlCommand cmd = new MySqlCommand(query, con);
 		cmd.Parameters.AddWithValue("@nev", temp.Nev);
 		cmd.Parameters.AddWithValue("@kor", temp.Kor);

 		cmd.ExecuteNonQuery();
 		ConnectClose();
	}
}</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#mysqlmoreres" class="collapseBtn" id="toMySqlMoreres">
                    MySql parancs futtatása ; több eredményt várunk vissza (pl.: select all)
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="mysqlmoreres">
<pre class="szovegek">
Lenti példa:    Sima MySql SELECT lekérdezés, ahol az adatokat egy TesztOsztaly listába tároljuk a megadott változók szerint adatlekérő metódust alkalmazva.
                Azaz amilyen adatot várunk, olyan adatlekérő metódust használunk.
Fő adatlekérő metódusok:
    GetString(index)
    GetDouble(index)
    GetBoolean(index)
    GetDateTime(index)
    GetInt32(index)
    GetDecimal(index)
    GetValue(index)
    IsDBNull(index)

</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('mysqlmoreresContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="mysqlmoreresContent"><code class="language-html">public List<TesztOsztaly> SelectAll()
{
	List&lt;TesztOsztaly&gt; adatok = new List&lt;TesztOsztaly&gt;();
	if(Connect())
	{
		string query = &quot;SELECT * FROM teszttabla;&quot;;
 		MySqlCommand cmd =  new MySqlCommand(query, con);
 		MySqlDataReader reader = cmd.ExecuteReader();
 		while(reader.Read())
 		{
 			adatok.Add(new TesztOsztaly(
                reader.GetInt32(0),
                reader.GetString(1),
                reader.GetInt32(2)
            ));
 		}
 		ConnectClose();
	}
 	return adatok;
}</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#mysqloneres" class="collapseBtn" id="toMySqlOneres">
                    MySql parancs futtatása ; egy eredményt várunk vissza (pl.: átlag kor)
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="mysqloneres">
<pre class="szovegek">
Lenti példa: Ugyanúgy egy SELECT lekérdezés, de mivel itt csak egyetlen adatot (a táblázat kor-ainak átlagát) várunk, ezért csak szimplán át kell konvertálni, hogy megfeleljen az adott változónak, ahová menteni szeretnénk.
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('mysqloneresContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="mysqloneresContent"><code class="language-html">public double AtlagKor()
{
	double AvgAge = 0;
	if(Connect())
	{
		string query = "SELECT AVG(kor) FROM teszttabla;";
		MySqlCommand cmd = new MySqlCommand(query, con);
		if(cmd.ExecuteScalar() != null)
		{
			AvgAge = Convert.ToDouble(cmd.ExecuteScalar());
		}
		ConnectClose();
	}
	return AvgAge;
}</code></pre>
                    </div>
<pre class="szovegek">
    
Példa 2:</pre>
                <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('mysqloneresContent2')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="mysqloneresContent2"><code class="language-html">.xaml.cs:

private void Hirdetesek(object sender, RoutedEventArgs e)
{
    List&lt;Seller&gt; sellers = getSellers();

    Seller selectedSeller = (Seller)List.SelectedItem;
    string selectedName = selectedSeller.Name;

    DBConnect db = new DBConnect(&quot;127.0.0.1&quot;, &quot;ingatlan&quot;, &quot;root&quot;, &quot;&quot;);
    int hirdetesdb = Convert.ToInt32(db.HirdetesDb(selectedName));

    hirdetesek.Content = hirdetesdb;
}

Mysql meghívás class-ból:

public int HirdetesDb(string nev)
{
    int hirdetesdb = 0;
    if (Connect())
    {
        string query = $"SELECT COUNT(sellers.name) FROM sellers INNER JOIN realestates ON (sellers.id = realestates.sellerId) WHERE sellers.name = @nev;";
        MySqlCommand cmd = new MySqlCommand(query, con);
        cmd.Parameters.AddWithValue("@nev", nev);
        if (cmd.ExecuteScalar() != null)
        {
            hirdetesdb = Convert.ToInt32(cmd.ExecuteScalar());
        }
        ConnectClose();
    }
    return hirdetesdb;
}</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#mysqluse" class="collapseBtn" id="toMySqlUse">
                    MySql => megírt függvények elérése (pl.: Gombra kattintás)
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="mysqluse">
<pre class="szovegek">
Lenti példa:    - Létrehozunk egy DBConnect osztályú (korábban létrehozott) változót, aminek megadjuk a MySql elérési útját
                - Lefuttatjuk a korábban létrehozott InsertData függvényt a db változón és 
                  paraméterül adjuk a feltölteni kívánt adatokat.
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('mysqluseContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="mysqluseContent"><code class="language-html">DBConnect db = new DBConnect("127.0.0.1", "teszt", "root", "");
db.InsertData(new TesztOsztaly("István", 18));</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#inheritance" class="collapseBtn" id="toInheritance">
                    Osztály származtatása
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="inheritance">
<pre class="szovegek">
- Ős / szülő osztály: Az az osztály, amelyet származtatunk és amit a származtatás során kiegészítünk.
- Gyerek / származtatott osztály: Az az osztály, ami az ős kiegészítésével jön létre.

Öröklődésnél átvesszük az ős osztály mezőit, metódusait, emellett lehetőségünk van a továbbiakban új mezőkkel, metódusokkal kiegészíteni. Fontos: metódusokat, adattagokat hozzáadni és módosítani tudunk, de eldobni belőle nem. Tehát a gyerek osztály mindent tud, amit az ős osztály.

C# esetén minden osztály csak egy ősosztállyal rendelkezhet.

Láthatóságok:
- private
- public
- protected - Csak az ős és a származtatott osztály férhet hozzá.

Öröklődés során minden mező automatikusan megtartja az ősosztálybeli jelentését. Ekkor az ős publikus mezői a gyerek osztályban is publikus mezők és a protected mezők a gyerek osztályban is protectedek lesznek.

Az ős private mezői a gyerek osztályban sem lesznek elérhetőek ezáltal.

Amikor a gyerek osztályt deklaráljuk, meg kell adni, hogy kit tekintsen ős osztálynak.

<b>Base:</b>

A base kulcsszó a konstruktornál arra hivatott, hogy az ős osztály paraméteres konstruktorára mutasson rá, ugyanis ott már az értékadás meg van írva, így a gyerek esetén nem kell még egyszer definiálnunk. (:base (adat))

<b>New:</b>

A new kulcsszó használata a gyerek osztály metódusa előtt, jelzi, hogy ez a metódus elrejti az alap osztály metódusát. Ez azért fontos, mert így a fordító tudja, hogy a gyerek osztály metódusa nem az alap osztály metódusának felülírása, hanem egy új metódus, amely elrejti az alap osztály metódusát.

<h4><b>Leegyszerűsítve példával:</b></h4>
Ember (Ős):
    - Ez a kiindiluó ősosztály, amihez hozzákötjük a Gyerek és Felnőtt osztályt (hisz egy gyerek és felnőtt ugyanúgy Ember)
        - Ezáltal, ha például a Labak() függvényt meghívjuk a programon belül egy Gyerek vagy Felnőtt
          osztállyal rendelkezővel, úgy azok ugyanúgy 2 lábúak lesznek
        - Valamint így nem kell külön a Gyerek és Felnőtt osztálynak is nevet megadni.
    - protected string Név { get => név; set => név = value; }
        - protected, hogy az ősosztály neve csak a gyerekosztályokban legyen elérhető

Gyerek : Ember (Gyerek):
&&
Felnőtt : Ember (Gyerek):
    - Származtatott gyerekosztályok
    - Külön függvényeket lehet megadni nekik, amit csak a saját osztályukban tudnak használni.
        - Azaz egy gyerek csak Iszik(), egy felnőtt pedig csak Drogozik().
    - Programon belül lehet őket létrehozni a Felnőtt vagy Gyerek osztály előtaggal.
    - public Gyerek(string név) : base(név)
      {
      }
        - Alapjáraton üres, mert csak az származtatott név változót akarjuk tárolni
        - public Gyerek(string név) után kell egy : base(név) => feltüntetni, hogy honnan örökölje a nevet
        - Ide lehetne plusz változókat hozzáadni
            - Ehhez a Gyerek(string név) + {} állományt kell kiegészíteni
            - Példa változó hozzáadásához:
                public Gyerek(string név, bool iskolas) : base(név)
                {
                    this.Iskolas = iskolas;
                }
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('inheritanceContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="inheritanceContent"><code class="language-html">class Ember
{
    private string név;

    public Ember(string név)
    {
        this.Név = név;
    }

    protected string Név { get => név; set => név = value; }
    public string Labak()
    {
        return Név + "-nak/nek 2 lába van (jobb esetben)";
    }
}
class Gyerek : Ember
{
    public Gyerek(string név) : base(név)
    {
    }
    public string Iszik()
    {
        return Név + " gyerek, kubut iszik.";
    }
}
class Felnőtt : Ember
{
    public Felnőtt(string név) : base(név)
    {
    }
    public string Drogozik()
    {
        return Név + " felnőtt, szétdrogozza magát.";
    }
}
internal class Program
{
    static void Main(string[] args)
    {
        Gyerek gyerek = new Gyerek("Ádám");
        Felnőtt felnőtt = new Felnőtt("Béla");

        Console.WriteLine("Ádám:");
        Console.WriteLine(gyerek.Labak());
        Console.WriteLine(gyerek.Iszik());

        Console.WriteLine("Béla:");
        Console.WriteLine(felnőtt.Labak());
        Console.WriteLine(felnőtt.Drogozik());
    }
}</code></pre>
                        <img src="../images/szarmaztatas-konzol.png" alt="">
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#abstract" class="collapseBtn" id="toAbstract">
                    Absztrakt osztály
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="abstract">
<pre class="szovegek">
- minden absztrakt osztálynak van legalább egy absztrakt metódusa (amihez nem tartozik megvalósítás)
- az absztrakt osztály nem példányosítható (mivel van egy absztrakt metódusa, s annak hívása futási hibával járna)
- a gyerekosztályban az absztrakt metódust kötelező felüldefiniálni, vagy a származtatott osztály is absztrakt osztály kell legyen
- absztrakt osztályból képzett származtatási lánc alján léteznie kell egy teljesen megvalósított osztálydefiníciónak
- A class szó elé kell tennünk az abstract kulcsszót, ezzel jelezve, hogy az egy absztrakt osztály lesz
- Az absztrakt metódus definiálásánál is kell az abstract kulcsszó:
- láthatóság abstract típus metódusnév(paraméterek);
- nincs metódustörzs, sőt még {} sem!
- ;-vel zárjuk!
- a származtatott osztályban a felüldefiniálás az override kulcsszóval történik

</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('abstractContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="abstractContent"><code class="language-html">abstract class Ember
{
    private string név;

    public Ember(string név)
    {
        this.Név = név;
    }

    protected string Név { get => név; set => név = value; }
    public abstract string Mozog(); //Jelöltem, hogy absztrakt metódus, nincs megvalósítás
}
class Gyerek : Ember
{
    public Gyerek(string név) : base(név)
    {
    }
    public override string Mozog()
    {
        return Név + " gyerek kúszik-mászik, futkározik.";
    }
}
class Felnőtt : Ember
{
    public Felnőtt(string név) : base(név)
    {
    }
    public override string Mozog()
    {
        return Név + " felnőtt ember sétál.";
    }
}
internal class Program
{
    static void Main(string[] args)
    {
        //Ember ember = new Ember("Cili");
        //Nem példányosítható, mivel absztrakt

        Gyerek gyerek = new Gyerek("Ádám");
        Felnőtt felnőtt = new Felnőtt("Béla");

        Console.WriteLine(gyerek.Mozog());
        Console.WriteLine(felnőtt.Mozog());
    }
}</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#grid" class="collapseBtn" id="toGrid">
                    WPF Grid (reszponzivitásért felelős)
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="grid">
<pre class="szovegek">
Lenti példa: 
    - Fő Grid-en belül lehet sorokra (RowDefinitions) és oszlopokra (ColumnDefinitions) bontva kialakítani
        - segít abban, hogy széthúzásnál-összehúzásnál is ugyanúgy jelenjen meg a content
    - Első &lt;Grid.ColumnDefinitions&gt; résznél a benne megadott &lt;ColumnDefinition/&gt; új oszlopokat csinál
        - Az oszlopoknak szélességi arányát Width=&quot;SZÁM*&quot lehet megadni
        - Ez ugyanúgy megoldható ugye sorokkal is, csak a Column helyett Row-t használunk, a Width helyett pedig Height-t.
    - Ha egy adott soron vagy oszlopon belül akarunk dolgozni, esetleg azon belüli új grid rendszereket létrehozni, 
      akkor azt a &lt;Grid Grid.Column=&quot;0&quot;&gt; megadásával lehet biztosítani.
    - Ha azt akarjuk megadni, hogy a kontent melyik sorban/oszlopban jelenjen meg, akkor azt a 
      Grid.Column=&quot;SZÁM&quot;/&gt; vagy Grid.Row=&quot;SZÁM&quot;/&gt; lehet megadni.
        - Hogyha azt akarjuk, hogy a másik sorba/oszlopba is átlógjon az adott elem, akkor a 
          Grid.ColumnSpan=&quot;SZÁM(Hány oszlopba lógjon át)&quot;/&gt; Grid.RowSpan=&quot;SZÁM(Hány sorba lógjon át)&quot;/&gt; teszi ezt lehetővé
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('gridContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="gridContent"><code class="language-html">&lt;Grid&gt;
    &lt;Grid.ColumnDefinitions&gt;
        &lt;ColumnDefinition Width=&quot;2*&quot;/&gt;
        &lt;ColumnDefinition Width=&quot;4*&quot;/&gt;
    &lt;/Grid.ColumnDefinitions&gt;

    &lt;Grid Grid.Column=&quot;0&quot;&gt;
        &lt;ListBox Margin=&quot;10,10,10,10&quot;/&gt;
    &lt;/Grid&gt;

    &lt;Grid Grid.Column=&quot;1&quot;&gt;
        &lt;Grid.ColumnDefinitions&gt;
            &lt;ColumnDefinition Width=&quot;*&quot;/&gt;
            &lt;ColumnDefinition Width=&quot;2*&quot;/&gt;
        &lt;/Grid.ColumnDefinitions&gt;
        &lt;Label Content=&quot;Elad&oacute; neve:&quot; HorizontalAlignment=&quot;Stretch&quot; Margin=&quot;10,10,0,0&quot; VerticalAlignment=&quot;Top&quot; Grid.Column=&quot;0&quot;/&gt;
        &lt;Label Content=&quot;&quot; Margin=&quot;10,10,10,0&quot; VerticalAlignment=&quot;Top&quot; Grid.Column=&quot;1&quot;/&gt;
        &lt;Button Content=&quot;Button&quot; Margin=&quot;10,63,20,0&quot; VerticalAlignment=&quot;Top&quot; Grid.Column=&quot;0&quot; Grid.ColumnSpan=&quot;2&quot;/&gt;

    &lt;/Grid&gt;

&lt;/Grid&gt;</code></pre>
                    </div>
                </div>

                <button data-bs-toggle="collapse" data-bs-target="#wpflist" class="collapseBtn" id="toWpfList">
                    WPF listaBox vagy Táblázat (DataGrid) feltöltése az osztály elemeivel (nem a for ciklussal)
                    <br>+ Adatkötés használata
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="wpflist">
<pre class="szovegek">
Lenti példa:    - Ha már definiálva van a Lista, amit hozzá akarunk adni a WPF listatartományhoz, akkor a
                   List(wpf listanév).ItemsSource = LISTANÉV feldolgozza a Lista osztályt.
                   Ugyanezen az alapon működik a <b>táblázat</b> feltöltése is (pl.: Tabla.ItemsSource = CLASSLISTA_NEVE;)
                   Mivel egy osztály listáról van szó, ezért ki kell választani, hogy mit akarunk belőle megjeleníteni
                     Ehhez a List(wpf listanév).DisplayMemberPath = Osztályváltozó_neve szükséges
                     Például a List.DisplayMemberPath = &quot;Name&quot;; itt csak az osztálylista neveit jeleníti meg a wpf listában.
                    
                - Hogyha egy content-et (például label-nek) a kiválasztott lista eleméhez tartozó osztálybeli változójával szeretnénk megjeleníteni:
                    XAML Label-ön belül megadjuk: Content=&quot;{Binding ElementName=LISTANÉV, Path=SelectedItem.OSZTÁLYVÁLTOZÓ}&quot;
                        Így automatikusan hozzárendeli a kiválasztott listaelemhez tartozó másik változó értékét (példában ez a telefonszám)
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('wpflistContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="wpflistContent"><code class="language-html">.xaml.cs:

public MainWindow()
{
    InitializeComponent();
    Listafeltolt();
}

private List&lt;Seller&gt; getSellers()
{
    DBConnect db = new DBConnect(&quot;127.0.0.1&quot;, &quot;ingatlan&quot;, &quot;root&quot;, &quot;&quot;);
    List&lt;Seller&gt; sellers = db.SelectAll();

    return sellers;
}

private void Listafeltolt()
{
    List&lt;Seller&gt; sellers = getSellers();

    List.ItemsSource = sellers;
    List.DisplayMemberPath = &quot;Name&quot;;
    //List.DisplayMemberPath = &quot;Phone&quot;;
}

.xaml:

&lt;Label x:Name=&quot;telo&quot; Content=&quot;{Binding ElementName=List, Path=SelectedItem.Phone}&quot; Margin=&quot;10,41,10,0&quot; VerticalAlignment=&quot;Top&quot; Grid.Column=&quot;1&quot; Height=&quot;26&quot;/&gt;

</code></pre>
                    </div>
                </div>


                <button data-bs-toggle="collapse" data-bs-target="#cbox" class="collapseBtn" id="toCbox">
                    CheckBox és RadioButton használata
                </button>


                <div class="collapse mt-2 mb-5 pe-5" id="cbox">
<pre class="szovegek">
CheckBox és RadioButton beszúrása: 
    &lt;Groupbox&gt;&lt;WrapPanel&gt;&lt;CheckBox&gt;&lt;/CheckBox&gt;&lt;/WrapPanel&gt;&lt;/Groupbox&gt;
    &lt;Groupbox&gt;&lt;WrapPanel&gt;&lt;RadioButton&gt;&lt;/RadioButton&gt;&lt;/WrapPanel&gt;&lt;/Groupbox&gt;
</pre>
                    <div class="card card-body position-relative">
                        <button class="btn btn-sm btn-outline-secondary position-absolute top-0 end-0 m-2 copy-btn" onclick="copyCode('cboxContent')">
                            Másolás
                        </button>
                        <pre class="bg-light p-3 rounded" id="cboxContent"><code class="language-html">.xaml felépítése:

&lt;Grid&gt;
    &lt;GroupBox Header=&quot;Neme&quot; Margin=&quot;32,25,600,217&quot; FontSize=&quot;36&quot;&gt;
        &lt;WrapPanel Margin=&quot;0,0,16,0&quot; Orientation=&quot;Vertical&quot;&gt;
            &lt;RadioButton x:Name=&quot;r1&quot; Content=&quot;F&eacute;rfi&quot;/&gt;
            &lt;RadioButton x:Name=&quot;r2&quot; Content=&quot;Nő&quot;/&gt;
        &lt;/WrapPanel&gt;
    &lt;/GroupBox&gt;
    &lt;GroupBox Header=&quot;Kedvenc sz&iacute;n&quot; Margin=&quot;32,217,600,73&quot; FontSize=&quot;24&quot;&gt;
        &lt;WrapPanel Margin=&quot;0,0,16,0&quot; Orientation=&quot;Vertical&quot;&gt;
            &lt;CheckBox x:Name=&quot;cb1&quot; Content=&quot;K&eacute;k&quot;/&gt;
            &lt;CheckBox x:Name=&quot;cb2&quot; Content=&quot;R&oacute;zsasz&iacute;n&quot;/&gt;
        &lt;/WrapPanel&gt;
    &lt;/GroupBox&gt;
    &lt;Button Content=&quot;Ment&eacute;s&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;306,93,0,0&quot; VerticalAlignment=&quot;Top&quot; FontSize=&quot;72&quot; Height=&quot;243&quot; Width=&quot;338&quot; Click=&quot;mentes&quot;/&gt;
&lt;/Grid&gt;

.xaml.cs felépítése:

private void mentes(object sender, RoutedEventArgs e)
{
    string eredmeny = string.Empty;

    if ((bool)r1.IsChecked)
    {
        eredmeny += "Neme: " + r1.Content; // Férfi
    }
    else
    {
        eredmeny += "Neme: " + r2.Content; // Nő
    }
    eredmeny += " Kedvenc szín: ";

    //Checkbox

    if ((bool)cb1.IsChecked)
    {
        eredmeny += cb1.Content; // Kék
    }
    if((bool)cb2.IsChecked)
    {
        eredmeny += cb2.Content; // Rózsaszín
    }
    MessageBox.Show(eredmeny, "Kijelölve", MessageBoxButton.OK, MessageBoxImage.Information);
}
                        </code></pre>
                    </div>
                </div>



                </div>
            </div>
        </div>




        
        <script>
            function copyCode(elementId) {
                const codeElement = document.getElementById(elementId);
                const range = document.createRange();
                range.selectNode(codeElement);
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
                document.execCommand('copy');
                window.getSelection().removeAllRanges();

                const copyBtn = event.currentTarget;
                copyBtn.textContent = 'Másolva!';
                setTimeout(() => {
                    copyBtn.textContent = 'Másolás';
                }, 2000);
            }
        </script>
    </body>
</html>